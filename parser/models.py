#!/usr/bin/env python3

# WARNING: CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.
#
# WARNING: This file was manually modified and typed. Do not recompile it with TatSu.

from __future__ import annotations

from typing import Any, Optional, Literal
from dataclasses import dataclass

from tatsu.semantics import ModelBuilderSemantics
from tatsu.objectmodel import Node

type Expr = "BinaryExpr | UnaryExpr | CommaExpr | CondExpr | CastExpr | PostfixListExpr | PostfixFuncExpr | PostfixStructExpr | PostfixPointerExpr | PostfixCrementExpr | Identifier | Number"
type Stmt = "ExprStmt | CompoundStmt | IfStmt | ForStmt | WhileStmt | BreakStmt | ContinueStmt | ReturnStmt"

class minCModelBuilderSemantics(ModelBuilderSemantics):
    def __init__(self, context=None, types=None):
        types = [
            t for t in globals().values()
            if type(t) is type and issubclass(t, ModelBase)
        ] + (types or [])
        super().__init__(context=context, types=types)


@dataclass(eq=False)
class ModelBase(Node):
    pass


@dataclass(eq=False)
class Program(ModelBase):
    definitions: list[FuncDefinition] = None


@dataclass(eq=False)
class PostfixCrementExpr(ModelBase):
    op: str = None
    postfix: Expr = None


@dataclass(eq=False)
class PostfixFuncExpr(ModelBase):
    args: list[Expr] = None
    postfix: Expr = None


@dataclass(eq=False)
class VarDecl(ModelBase):
    expr: Expr = None
    name: Identifier = None
    type: TypeExpr = None


@dataclass(eq=False)
class Parameter(ModelBase):
    name: Identifier = None
    type: TypeExpr = None


@dataclass(eq=False)
class BinaryExpr(ModelBase):
    args: list[Expr] = None
    op: str = None


@dataclass(eq=False)
class UnaryExpr(ModelBase):
    expr: Expr = None
    op: str = None


@dataclass(eq=False)
class PostfixPointerExpr(ModelBase):
    field: Identifier = None
    postfix: Expr = None

@dataclass(eq=False)
class ForStmt(ModelBase):
    cond: ExprStmt = None
    init: VarDecl|ExprStmt = None
    loop: Stmt = None
    update_: Optional[Expr] = None


@dataclass(eq=False)
class CommaExpr(ModelBase):
    args: Any = None
    op: Any = None


@dataclass(eq=False)
class PostfixStructExpr(ModelBase):
    field: Identifier = None
    postfix: Expr = None


@dataclass(eq=False)
class CompoundStmt(ModelBase):
    items_: list[VarDecl|Stmt] = None


@dataclass(eq=False)
class CondExpr(ModelBase):
    check_expr: Expr = None
    false_expr: Expr = None
    true_expr: Expr = None


@dataclass(eq=False)
class BreakStmt(ModelBase):
    pass

@dataclass(eq=False)
class EmptyStmt(ModelBase):
    pass

@dataclass(eq=False)
class IfStmt(ModelBase):
    cond: Expr = None
    else_: Optional[Stmt] = None
    then: Stmt = None


@dataclass(eq=False)
class PostfixListExpr(ModelBase):
    index: Expr = None
    postfix: Expr = None


@dataclass(eq=False)
class Identifier(ModelBase):
    name: str = None


@dataclass(eq=False)
class ExprStmt(ModelBase):
    expression: Expr = None


@dataclass(eq=False)
class Number(ModelBase):
    type: str = None
    value: int|float = None


@dataclass(eq=False)
class CastExpr(ModelBase):
    casted: Expr = None
    type: TypeExpr = None


@dataclass(eq=False)
class WhileStmt(ModelBase):
    cond: Expr = None
    loop: Stmt = None


@dataclass(eq=False)
class ReturnStmt(ModelBase):
    value: Expr = None


@dataclass(eq=False)
class FuncDefinition(ModelBase):
    body: CompoundStmt = None
    name: Identifier = None
    params: Parameter = None
    type: TypeExpr = None


@dataclass(eq=False)
class TypeExpr(ModelBase):
    name: Optional[Identifier] = None
    type: Literal["long", "int", "short", "char", "void", "float", "double", "bool", "string", "struct"] = None


@dataclass(eq=False)
class ContinueStmt(ModelBase):
    pass
