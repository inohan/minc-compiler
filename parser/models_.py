#!/usr/bin/env python3

# WARNING: CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.

from __future__ import annotations

from typing import Any, Optional, Literal
from dataclasses import dataclass

from tatsu.semantics import ModelBuilderSemantics
from tatsu.objectmodel import Node

type Definition = FuncDefinition | Declaration
type Stmt = IfStmt | ForStmt | WhileStmt | CompoundStmt | ReturnStmt | ContinueStmt
type Expr = BinaryExpr | PostfixFuncExpr | PostfixStructExpr | PostfixPointerExpr | CastExpr | CondExpr | Reference | Dereference | PostfixCrementExpr | PostfixListExpr | CommaExpr | ParenthesisExpr | IdentifierExpr
type Declarator = PointerDeclarator | ArrayDeclarator | IdentifierDeclarator | FuncDeclarator | ParenthesisDeclarator
type DeclarationSpecifiers = TypeSpecifier
type TypeSpecifier = PrimitiveType | StructOrUnionSpecifier

class minCModelBuilderSemantics(ModelBuilderSemantics):
    def __init__(self, context=None, types=None):
        types = [
            t for t in globals().values()
            if type(t) is type and issubclass(t, ModelBase)
        ] + (types or [])
        super().__init__(context=context, types=types)


@dataclass(eq=False)
class ModelBase(Node):
    pass

@dataclass(eq=False)
class TypeName(ModelBase):
    decl: Optional[AbstractDeclarator] = None
    specifier: TypeSpecifier = None


@dataclass(eq=False)
class PostfixFuncExpr(ModelBase):
    args: list[Expr] = None
    postfix: Expr = None


@dataclass(eq=False)
class IfStmt(ModelBase):
    cond: Expr = None
    else_: Optional[Stmt] = None
    then: Stmt = None


@dataclass(eq=False)
class ArrayDeclarator(ModelBase):
    decl: Declarator = None
    size: Optional[Expr] = None

@dataclass(eq=False)
class ParenthesisDeclarator(ModelBase):
    decl: Declarator = None

@dataclass(eq=False)
class PrimitiveType(ModelBase):
    type: Literal["long", "int", "short", "char", "void", "float", "double", "bool", "string"] = None


@dataclass(eq=False)
class Number(ModelBase):
    type: Literal["int", "double", "float"] = None
    value: int|float = None


@dataclass(eq=False)
class PointerDeclarator(ModelBase):
    decl: Declarator = None
    ptr: Pointer = None

@dataclass(eq=False)
class IdentifierDeclarator(ModelBase):
    name: Identifier = None

@dataclass(eq=False)
class Declaration(ModelBase):
    decls: list[InitDeclarator] = None
    specifier: DeclarationSpecifiers = None


@dataclass(eq=False)
class Identifier(ModelBase):
    name: str = None


@dataclass(eq=False)
class CompoundStmt(ModelBase):
    items_: list[Declaration|Stmt] = None


@dataclass(eq=False)
class ForStmt(ModelBase):
    cond: Stmt = None
    init: Declaration|Stmt = None
    loop: Stmt = None
    update_: Expr = None


@dataclass(eq=False)
class UnaryExpr(ModelBase):
    expr: Expr = None
    op: str = None
    

@dataclass(eq=False)
class BinaryExpr(ModelBase):
    args: list[Expr] = None
    op: str = None
    
@dataclass(eq=False)
class ParenthesisExpr(ModelBase):
    arg: Expr = None

@dataclass(eq=False)
class IdentifierExpr(ModelBase):
    name: Identifier = None

@dataclass(eq=False)
class PostfixStructExpr(ModelBase):
    field: Identifier = None
    postfix: Expr = None


@dataclass(eq=False)
class ReturnStmt(ModelBase):
    value: Expr = None


@dataclass(eq=False)
class ContinueStmt(ModelBase):
    pass


@dataclass(eq=False)
class Pointer(ModelBase):
    ptr: str = None


@dataclass(eq=False)
class StructDeclaration(ModelBase):
    declarators: list[Declarator] = None
    specifier: TypeSpecifier = None


@dataclass(eq=False)
class PostfixPointerExpr(ModelBase):
    field: Identifier = None
    postfix: Expr = None


@dataclass(eq=False)
class Program(ModelBase):
    definitions: list[Definition] = None


@dataclass(eq=False)
class InitDeclarator(ModelBase):
    decl: Declarator = None
    init: Expr = None


@dataclass(eq=False)
class WhileStmt(ModelBase):
    cond: Expr = None
    loop: Stmt = None

@dataclass(eq=False)
class StructOrUnionSpecifier(ModelBase):
    members: Optional[list[StructDeclaration]] = None
    name: Optional[Identifier] = None
    type: Literal["struct", "union"] = None


@dataclass(eq=False)
class FuncDefinition(ModelBase):
    body: CompoundStmt = None
    decl: Declarator = None
    type: DeclarationSpecifiers = None


@dataclass(eq=False)
class CommaExpr(ModelBase):
    args: Expr = None
    op: str = None


@dataclass(eq=False)
class ExprStmt(ModelBase):
    expression: Optional[Expr] = None


@dataclass(eq=False)
class PostfixListExpr(ModelBase):
    index: Expr = None
    postfix: Expr = None


@dataclass(eq=False)
class CastExpr(ModelBase):
    arg: Expr = None
    type: TypeName = None


@dataclass(eq=False)
class BreakStmt(ModelBase):
    pass


@dataclass(eq=False)
class FuncDeclarator(ModelBase):
    decl: Declarator = None
    params: list[ParameterDeclaration] = None


@dataclass(eq=False)
class ParameterDeclaration(ModelBase):
    declarator: Declarator = None
    specifier: DeclarationSpecifiers = None


@dataclass(eq=False)
class PostfixCrementExpr(ModelBase):
    op: str = None
    postfix: Expr = None


@dataclass(eq=False)
class AbstractDeclarator(ModelBase):
    ptr: Pointer = None


@dataclass(eq=False)
class CondExpr(ModelBase):
    check_expr: Expr = None
    false_expr: Expr = None
    true_expr: Expr = None


@dataclass(eq=False)
class Reference(ModelBase):
    arg: Expr = None


@dataclass(eq=False)
class Dereference(ModelBase):
    arg: Expr = None